using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Emit;
using NPOI.SS.UserModel;
using NPOI.XSSF.UserModel;
using Paltry.Others;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnityEditor;
using UnityEngine;

namespace Paltry
{
    //流程:对于每一个book,其中的每一张sheet,进行ParseSheet
    //如果省略了变量类型,则通过DataParser推断变量类型
    //KVP Sheet:在解析时就完成数据读取,因为KVP实例类似于单例
    //CSV Sheet:先构建代码,再创建对象并填入数据
    public class DT_CodeWriter
    {
        StringBuilder Book_Properties = new ("\n");
        StringBuilder Book_Fields = new ("\n");
        StringBuilder Book_ClassDef = new ("\n");

        string CodeInformation_using =>
            "///<Auto-Generated>\n" +
            "///    This code was generated by <see cref=\"Paltry.DT_CodeWriter\"/>\n" +
            "///    You shouldn't edit it because any changes will be overwrite when regenerate\n" +
            "///    Generate Time Stamp:" + DateTime.Now + "\n" +
            "using UnityEngine;\n" +
            PaltryCongfig.SO.DT_Usings_Str +
            "#pragma warning disable 1591\n";
        public string CODE => 
            CodeInformation_using +
            DT_NamespaceBegin +
            Indent_NS + $"public class {DT_ClassName}\n" +
            Indent_NS + "{" +
            Book_Properties +
            Book_Fields +
            Book_ClassDef +
            Indent_NS + "}\n" +
            DT_NamespaceEnd;

        //当前所处位置应采用的缩进,若不需要命名空间,在此处修改即可
        const string Indent_NS = "\t";//namespace
        const string Indent_DT = "\t\t";//DataTable,也就是最外层的类
        const string Indent_BK = "\t\t\t";//Book 类
        const string Indent_ST = "\t\t\t\t";//Sheet 类,包括Entry和KVP

        const int MetaDataCount = 3;//元数据所占的行(列)数

        public static string DT_CodePath => PaltryCongfig.SO.DT_CodeDirectory
            + '/' + PaltryCongfig.SO.DT_ClasssName + ".cs";
        private string DT_ClassName => PaltryCongfig.SO.DT_ClasssName;
        private string DT_NamespaceBegin
        {
            get
            {
                if (string.IsNullOrWhiteSpace(PaltryCongfig.SO.DT_Namespace))
                    return null;
                else
                    return "namespace " + PaltryCongfig.SO.DT_Namespace + "\n{\n";
            }
        }
        private string DT_NamespaceEnd
        {
            get
            {
                if (string.IsNullOrWhiteSpace(PaltryCongfig.SO.DT_Namespace))
                    return null;
                else return "}";
            }
        }


        /// <summary>
        /// 根据所有WorkBook,产生DataTable类,若有语法错误则不写入
        /// </summary>
        public void Write(List<(XSSFWorkbook, string)> books)
        {
            Book_Fields.AppendLine(Indent_DT + $"private static {DT_ClassName} instance = new();");

            foreach (var book in books)
                ParseBook(book);

            if (TryCompile())
                File.WriteAllText(DT_CodePath, CODE);    
            return;
        }

        private bool TryCompile()
        {
            SyntaxTree syntaxTree = CSharpSyntaxTree.ParseText(
                CODE +"namespace System.Runtime.CompilerServices { class IsExternalInit { } }"
                , new CSharpParseOptions(LanguageVersion.CSharp9));

            string editorDataPath = EditorApplication.applicationContentsPath;
            string unityEnginePath = Path.Combine(editorDataPath,
                "Managed", "UnityEngine", "UnityEngine.dll");
            string unityCoreModulePath = Path.Combine(editorDataPath,
                "Managed", "UnityEngine", "UnityEngine.CoreModule.dll");
            string projectAssemblyPath = Path.Combine(Application.dataPath,
                "..", "Library", "ScriptAssemblies", "Assembly-CSharp.dll");

            CSharpCompilation compilation = CSharpCompilation.Create(
                "TemporaryCompilation",
                new[] { syntaxTree },
                new[]
                {
                MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
                MetadataReference.CreateFromFile(unityEnginePath),
                MetadataReference.CreateFromFile(unityCoreModulePath),
                MetadataReference.CreateFromFile(projectAssemblyPath),

                },
                new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary)
                    .WithGeneralDiagnosticOption(ReportDiagnostic.Suppress));//忽略warning

            EmitResult result = compilation.Emit(Stream.Null);
            if (result.Success)
                return true;
            else
            {
                StringBuilder error = new();
                foreach (var i in result.Diagnostics)
                    error.Append(i);
                Debug.LogError(StrUtil.LogCyan("<DataTable>解析数据表时出错:"+error));
                return false;
            }
        }
        private void ParseBook((XSSFWorkbook workbook,string bookName) book)
        {
            string name = book.bookName;
            Book_Properties.AppendLine(Indent_DT + $"public static {"_"+name+"Book"} {name} => instance.{"_"+name};");
            Book_Fields.AppendLine(Indent_DT + $"private {"_"+name+"Book"} {"_"+name} = new();");
            Book_ClassDef.AppendLine(Indent_DT +$"public class {"_"+name+"Book"}");
            Book_ClassDef.AppendLine(Indent_DT + "{");

            XSSFWorkbook workbook = book.workbook;
            StringBuilder sheet_Fields = new ();
            StringBuilder sheet_ClassDef = new ();

            for (int i = 0; i < workbook.NumberOfSheets; i++)
                ParseSheet(workbook[i],sheet_Fields,sheet_ClassDef);

            Book_ClassDef.Append(sheet_Fields).Append(sheet_ClassDef);
            Book_ClassDef.AppendLine(Indent_DT + "}");
        }

        private void ParseSheet(ISheet sheet,StringBuilder sheet_Fields,StringBuilder sheet_ClassDef)
        {
            switch (sheet.GetRow(0).GetCellStr(0))
            {
                case "#CSV":
                    ParseSheet_CSV(sheet,sheet_Fields,sheet_ClassDef); break;
                case "#KVP":
                    ParseSheet_KVP(sheet, sheet_Fields, sheet_ClassDef); break;
                default:
                    throw new FormatException(StrUtil.LogCyan($"<DataTable>{sheet.SheetName}的sheet类型不符合要求"));
            }

        }
        private void ParseSheet_CSV(ISheet sheet, StringBuilder sheet_Fields,StringBuilder sheet_ClassDef)
        {
            sheet_Fields.AppendLine(Indent_BK + $"public readonly {sheet.SheetName+"Entry"}[] {sheet.SheetName} =");
            sheet_Fields.AppendLine(Indent_BK + "{");

            StringBuilder sheet_ClassDef_Code = new();//sheet定义的代码部分(非注释部分)
            sheet_ClassDef_Code.AppendLine(Indent_BK + $"public record {sheet.SheetName+"Entry"}");
            sheet_ClassDef_Code.AppendLine(Indent_BK +  "(");

            //在第一列查找变量行和注释行
            ICell[] column1 = sheet.Columns().First();
            IRow varRow = column1.First(x => x.ToString() == "#变量").Row;
            IRow commentRow = column1.First(x => x.ToString() == "#注释").Row;

            //构建Entry类
            StringBuilder sheet_Comments = new();
            string[] entryTypes = new string[varRow.LastCellNum - 1];
            for (int i=1; i<varRow.LastCellNum; i++)
            {
                var comment = commentRow.GetCellStr(i);
                var (type, var) = SplitOrInferType(sheet, varRow.GetCell(i), SheetType.CSV);
                sheet_Comments.AppendLine(Indent_BK + $"/// <param name=\"{var}\">{comment}</param>");
                sheet_ClassDef_Code.AppendLine(Indent_ST + $"{type} {var},");
                entryTypes[i-1] = type;
            }
            sheet_ClassDef_Code.ReplaceLast(",", $"\n{Indent_BK});\n");
            sheet_ClassDef.Append(sheet_Comments).Append(sheet_ClassDef_Code);

            //为Entry数组填入数据
            foreach (IRow row in sheet.Rows().Skip(3))
            {
                sheet_Fields.Append(Indent_ST+"new(" );
                for (int i = 1; i < varRow.LastCellNum; i++)
                {
                    sheet_Fields.Append(DT_Parser.BuildLiteral(
                        row.GetCellStr(i), entryTypes[i - 1])+",");
                }
                sheet_Fields.Replace(",", "),\n",sheet_Fields.Length-1,1);
            }
            sheet_Fields.AppendLine(Indent_BK + "};");
        }

        private void ParseSheet_KVP(ISheet sheet, StringBuilder sheet_Fields, StringBuilder sheet_ClassDef)
        {
            sheet_Fields.AppendLine(Indent_BK + $"public readonly {sheet.SheetName + "KVP"} {sheet.SheetName} = new();");
            sheet_ClassDef.AppendLine(Indent_BK + $"public class {sheet.SheetName + "KVP"}")
                .AppendLine(Indent_BK + "{");

            //在第二行查找变量列和注释列的索引
            int varIndex=-1, commentIndex=-1, valueIndex=-1;
            foreach(var cell in sheet.GetRow(1))
            {
                (varIndex, commentIndex, valueIndex) = cell.ToString() switch
                {
                    "#变量" => (cell.ColumnIndex, commentIndex, valueIndex),
                    "#注释" => (varIndex, cell.ColumnIndex, valueIndex),
                    "#1" => (varIndex, commentIndex, cell.ColumnIndex),
                    _ => (varIndex,commentIndex,valueIndex)
                };
                if (varIndex >=0 && commentIndex >=0 && valueIndex >=0) break;
            }

            foreach (IRow row in sheet)//空行不会被遍历到
            { 
                if (row.GetCellStr(0).StartsWith('#')) continue;

                var (type,var) = SplitOrInferType(sheet, row.GetCell(varIndex), SheetType.KVP);
                var comment = row.GetCellStr(commentIndex);
                var value = DT_Parser.BuildLiteral(row.GetCellStr(valueIndex),type);
                sheet_ClassDef.AppendLine(Indent_ST + $"/// <summary> {comment} </summary>")
                    .AppendLine(Indent_ST + $"public readonly {type} {var} = {value};");
            }

            sheet_ClassDef.AppendLine(Indent_BK + "}");
        }

        public static(string type, string var) SplitOrInferType(ISheet sheet,ICell cell,SheetType sheetType)
        {
            string varCellStr = cell.ToString();
            if(varCellStr.Contains(':'))
            {
                var res = varCellStr.Split(":");
                return (res[1], res[0]);
            }
            else
            {
                var value = FindValueCellStr(sheet, cell,sheetType);
                if(DT_Parser.TryParseType(value, out var type))
                    return (type,varCellStr);
                else 
                    throw new FormatException(StrUtil.LogCyan(
                    $"<DataTable>无法推断出表格变量数据类型,表格变量位于:{sheet.SheetName}[{cell.RowIndex+1},{cell.ColumnIndex+1}]"));
            }

            string FindValueCellStr(ISheet sheet,ICell cell,SheetType sheetType)
            {
                if (sheetType == SheetType.CSV)
                    return sheet.GetRow(3).GetCellStr(cell.ColumnIndex);
                else if (sheetType == SheetType.KVP)
                    return cell.Row.GetCellStr(2);
                else return null;
            }
        }

        public enum SheetType
        {
            CSV,KVP
        }
        //private Type Compile()
        //{
        //    string filePath = DT_CodePath + DT_ClassName;

        //    //使用这些功能需要unity api level为.Net Framework
        //    CompilerParameters compilerParams = new()
        //    {
        //        GenerateInMemory = true, // 将程序集加载到内存中
        //        GenerateExecutable = false, // 编译成库文件
        //        IncludeDebugInformation = false, // 不包含调试信息
        //        TreatWarningsAsErrors = false, // 将警告视为错误
        //        CompilerOptions = $"/doc:{filePath + ".xml"} /optimize", // 优化编译器选项
        //    };
            
        //    // 添加引用
        //    string unityEngineDLL =
        //        Path.GetDirectoryName(typeof(UnityEngine.Object).Assembly.Location);
        //    string currentUnityProject = Assembly.GetExecutingAssembly().Location;
        //    compilerParams.ReferencedAssemblies.AddRange(
        //        new[]{ "System.dll",unityEngineDLL,currentUnityProject});

        //    using var codeProvider = new CSharpCodeProvider();
        //    var compilerResults =
        //        codeProvider.CompileAssemblyFromSource(compilerParams, CODE);

        //    // 检查编译结果
        //    if (compilerResults.Errors.Count > 0)
        //    {
        //        Debug.Log("编译错误：");
        //        foreach (CompilerError error in compilerResults.Errors)
        //            Debug.Log("Line"+error.Line+":"+ error.ErrorText);
        //    }
        //    else
        //    {
        //        // 编译成功
        //        Debug.Log("编译成功！");
        //        File.WriteAllText(Application.dataPath  +"\\Scripts\\"+ DT_ClassName+".cs",CODE);
        //        // 加载程序集并执行其中的代码
        //        var assembly = compilerResults.CompiledAssembly;
        //        var type = assembly.GetType(DT_ClassName).GetNestedType("TestDataBook")
        //            .GetNestedType("Sheet2KVP");
        //        var fieldInfo = type.GetField("path");
        //        var obj = Activator.CreateInstance(type);
        //        var arr = fieldInfo.GetValue(obj) as Array;
        //        foreach(var i in arr)
        //            Debug.Log(i);
        //    }

        //    return compilerResults.CompiledAssembly.GetType(DT_ClassName);
        //}

        // 流程:
        //1.通过路径,读取到所有的xlsx文件,对于每一个xlsx,获取其中所有的元数据
        //以生成对应的类, 完成之后编译所有的类
        //2.在第一步中,每个sheet都保存了实际数据的起点,此时创建生成类的实例
        //并根据实际数据的起点, 填入数据
        //3.将实例序列化,保存在固定位置
        //4.运行时,可自行加载序列化后的对象,从而使用其中的数据
        //* 每次运行时, 自动检查数据表是不是最新的(通过修改时间判断)如果不是,重新读表并序列化
        //* 该检查仅在编辑器下进行, 因为打包发布后数据表就确定了不会更改了
    }

    public class CSVSheet<TEntry>  
    {
        public readonly TEntry[] Entries;
        public CSVSheet()
        {
        }
    }
    public class TestGen
    {
        //public static void Load()//该方法在运行时自行调用,并在合适时调用Unload
        //{
        //    instance = JsonMgr.Load<TestGen>("数据表路径");//反序列化
        //}
        //public static void Unload()
        //{
        //    instance = null;
        //}
        public static _EnemyBook Enemy => instance._Enemy;
        public static _LevelBook Level => instance._Level;
        public static _MapBook Map => instance._Map;


        private static TestGen instance = new();
        private _EnemyBook _Enemy = new();
        private _LevelBook _Level=new();     
        private _MapBook _Map=new();
        public class _EnemyBook
        {
            public readonly  NormalEnemyEntry[] NormalEnemy;
            public readonly  EliteEnemyEntry[] EliteEnemy;
            public readonly  BossEntry[] Boss;
            public class NormalEnemyEntry { }
            public class EliteEnemyEntry
            {
                /// <summary> 攻击力 </summary>
                public readonly int ATK;
                /// <summary>
                /// 防御力
                /// </summary>
                public readonly float DEF = 3;
                /// <summary>
                /// 名字
                /// </summary>
                public readonly string name;
                /// <summary>
                /// 敌人位置
                /// </summary>
                public readonly Vector3 Position;
            }
            public class BossEntry { }
        }
        public class _LevelBook
        {
            public readonly CSVSheet<LevelEntry> Levels;
            public readonly TutorialLevelKVP TutorialLevel;
            public class LevelEntry
            {

            }
            public class TutorialLevelKVP
            {
                float[] fs = { 2.4f, 3, 4 };
                string[] ss = { "dsf", "fsd", "sfd" };
                bool[]bs= { false, true };
                char[] cs = { 'a', 'b' };
                Vector2[] v2s = {new (2,3),new (4,3)};
                Vector2 pos = new();
                int[,] ints = { { 1, 2, 3 }, { 43, 43, 4 }, };
            }
        }
        public class _MapBook
        {
            public readonly MapKVP Map;
            public class MapKVP
            {
                public readonly int LevelCount = 3;
                public readonly string CurLevelName = "浮点数";
            }
        }
    }

    public static class StringBuilderExtension
    {
        /// <summary>
        /// 从末尾开始,替换掉第一个满足条件的字符串(仅替换第一个)
        /// </summary>
        /// <param name="sb"></param>
        /// <param name="oldValue"></param>
        /// <param name="newValue"></param>
        /// <returns></returns>
        public static StringBuilder ReplaceLast(this StringBuilder sb,string oldValue,string newValue)
        {
            int start = sb.ToString().LastIndexOf(oldValue);
            sb.Replace(oldValue, newValue, start, oldValue.Length);
            return sb;
        }
    }
    public static class NPOIExtension
    {
        public static string GetCellStr(this IRow row,int index)
        {
            return row.GetCell(index)?.ToString();
        }
        public static IEnumerable<IRow> Rows(this ISheet sheet)
        {
            foreach (IRow row in sheet)
                yield return row;
        }
        public static IEnumerable<ICell[]> Columns(this ISheet sheet)
        {
            int rowCount = sheet.LastRowNum+1;
            int columnCount = sheet.GetRow(0).LastCellNum;
            IRow[] rows = sheet.Rows().ToArray();
            for (int i = 0; i < columnCount; i++)
            {
                ICell[] column = new ICell[rowCount];
                for (int j = 0; j < rowCount; j++)
                    column[j] = rows[j].GetCell(i);
                yield return column;
            }
        }
    }
}
 